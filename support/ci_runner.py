"""Module runs a job in Travis-CI."""
import json
import logging
from os import environ, path as osp, EX_SOFTWARE
from subprocess import Popen, PIPE

# noinspection PyPackageRequirements
import click

from support.post_plan import post_comment
from support.sectionless_configparser import SectionLessConfigParser

LOG = logging.getLogger(__name__)
DEFAULT_TERRAFORM_VARS = '.env/tf_env.json'


def get_action(branch=None, pull_request=False):
    """
    Detect terraform action based on input branch and pull_request flag.
    If it cannot detect the action (branch is not given or error) the action
    will be ``plan``.

    :param branch: Branch name.
    :type branch: str
    :param pull_request: Whether the branch is a pull request.
    :type pull_request: bool
    :return: "apply" or "plan". It will return "apply" only if the branch is
        "master" and not a pull request.
    :rtype: str
    """
    if branch == "master" and not pull_request:
        return 'apply'

    return 'plan'


def parse_plan(output):
    """
    Parse a string given by output and return a tuple with execution plan.

    :param output: Output of terraform plan command.
    :type output: str
    :return: Tuple with number of changes (add, change, destroy)
    :rtype: tuple
    """
    add = None
    change = None
    destroy = None
    try:
        for line in output.splitlines():
            if line.startswith('Plan: '):
                split_line = line.split()
                # Plan: 4 to add, 11 to change, 7 to destroy.
                add = int(split_line[1])
                change = int(split_line[4])
                destroy = int(split_line[7])
            elif line == "No changes. Infrastructure is up-to-date.":
                return 0, 0, 0

    except AttributeError:
        pass

    return add, change, destroy

def run_job(path, action):
    """
    Run a job for a given module specified by path.

    :param path: Path to terraform module.
    :type path: str
    :param action: "apply" or "plan". Other action are not supported.
    :return: Dictionary with run report:

        {
            'success': True or False
            'add': x,
            'change': x,
            'destroy': x,
            'raw': <original content of the plan output>
        }
    :rtype: dict
    """
    returncode, cout, cerr = execute(
        [
            'make',
            '-C', path,
            action
        ]
    )
    status = {
        'success': returncode == 0,
        'stderr': cerr,
        'stdout': cout
    }
    parse_tree = parse_plan(cout.decode('utf-8'))
    status['add'] = parse_tree[0]
    status['change'] = parse_tree[1]
    status['destroy'] = parse_tree[2]

    return status

def execute(cmd):
    """
    Execute a command and return a tuple with return code, STDOUT and STDERR.

    :param cmd: Command.
    :type cmd: list
    :return: Tuple (return code, STDOUT, STDERR)
    :rtype: tuple
    """
    proc = Popen(cmd, stdout=PIPE, stderr=PIPE)
    cout, cerr = proc.communicate()
    return proc.returncode, cout, cerr

def render_comment(status):
    """
    Format status with markdown syntax to publish it as a comment.

    :param status: Status generated by a series of terraform plan.
        For example::

        {'cloudflare': {'add': 0,
                        'change': 0,
                        'destroy': 0,
                        'stderr': b'',
                        'success': True},
         'github': {'add': 0,
                    'change': 0,
                    'destroy': 0,
                    'stderr': b'',
                    'success': True},
         'management_app': {'add': 0,
                            'change': 0,
                            'destroy': 0,
                            'stderr': b'',
                            'success': True},
         'prod/recovery_app': {'add': 0,
                               'change': 0,
                               'destroy': 0,
                               'stderr': b'',
                               'success': True},
         'prod/web_app': {'add': 0,
                          'change': 0,
                          'destroy': 0,
                          'stderr': b'',
                          'success': True},
         'stage/recovery_app2': {'add': 0,
                                 'change': 0,
                                 'destroy': 0,
                                 'stderr': b'',
                                 'success': True},
         'stage/web_app': {'add': 0,
                           'change': 0,
                           'destroy': 0,
                           'stderr': b'',
                           'success': True}}
    :type status: dict
    :return: Markdown formatted comment
    :rtype: str
    """
    map_change = {
        'add': '![#c5f015](https://placehold.it/15/c5f015/000000?text=+) ',
        'change': '![#1589F0](https://placehold.it/15/1589F0/000000?text=+) ',
        'destroy': '![#f03c15](https://placehold.it/15/f03c15/000000?text=+) '
    }
    def flag(change):
        for k in status.keys():
            if status[k][change] > 0:
                return map_change[change]

        return ''

    comment = " | ".join(
        [
            'Module',
            'Success',
            flag('add') + 'Add',
            flag('change') + 'Change',
            flag('destroy') + 'Destroy'
        ]
    )
    comment += '\n' + "--- | --- | ---: | ---: | ---:" + '\n'

    tag_map = {
        True: '![#c5f015](https://placehold.it/15/c5f015/000000?text=+)',
        False: '![#f03c15](https://placehold.it/15/f03c15/000000?text=+)'
    }
    for key in status.keys():
        changes = {}
        for change in ['add', 'change', 'destroy']:
            if status[key][change] > 0:
                changes[change] = '**%d**' % status[key][change]
            else:
                changes[change] = status[key][change]

        line = "**{module}** | {tag} `{success}` " \
               "| {add} | {change} | {destroy}".format(
                   module=key,
                   tag=tag_map[status[key]['success']],
                   success=status[key]['success'],
                   add=changes['add'],
                   change=changes['change'],
                   destroy=changes['destroy'])
        comment += line + '\n'
    for key in status.keys():
        outs = {}
        for out in ['stdout', 'stderr']:
            if isinstance(status[key][out], bytes):
                outs[out] = status[key][out].decode('utf-8')
            else:
                outs[out] = status[key][out]

        line = """
# **{module}**

## stdout

{cout}

## stderr

{cerr}
""".format(module=key,
           cout='```' + outs['stdout'] + '```'
           if outs['stdout'] else '_no output_',
           cerr='```' + outs['stderr'] + '```'
           if outs['stderr'] else '_no output_',
           )
        comment += line

    return comment


def setup_environment(config_path=DEFAULT_TERRAFORM_VARS):
    """
    Read AWS variables from Terraform config and set them
    as environment variables
    """
    with open(config_path) as fp:
        tf_vars = json.loads(fp.read())

    environ['AWS_ACCESS_KEY_ID'] = tf_vars['TF_VAR_aws_access_key']
    environ['AWS_SECRET_ACCESS_KEY'] = tf_vars['TF_VAR_aws_secret_key']
    environ['GITHUB_TOKEN'] = tf_vars['TF_VAR_github_token']

    for k, v in tf_vars.items():
        environ[k] = v


@click.command()
@click.argument('module_name', nargs=-1)
@click.option(
    '--modules-path',
    default='terraform',
    help='Path to directory with Terraform modules',
    show_default=True,
)
@click.option(
    '--force-run',
    help='Force to run terraform action',
    is_flag=True,
    default=False
)
@click.option(
    '--env-file',
    help='A JSON file with terraform environment variables',
    default=DEFAULT_TERRAFORM_VARS
)
def ci_runner(modules_path, module_name, force_run, env_file):
    """
    Run CI/CD job in Travis-CI.

    The command takes module names as arguments.
    """
    logging.basicConfig(level=logging.INFO)
    try:
        pull_request = not environ['TRAVIS_PULL_REQUEST'] == "false"

    except KeyError:
        pull_request = False

    action = get_action(
        branch=environ.get('TRAVIS_BRANCH', None),
        pull_request=pull_request
    )

    setup_environment(env_file)
    status = {}
    for mod in module_name:
        LOG.info('Processing %s', mod)
        if pull_request or action == 'apply' or force_run:
            status[mod] = run_job(
                osp.join(
                    modules_path, mod
                ),
                action
            )
            if status[mod]['success']:
                LOG.info('%s success: %s', mod, status[mod]['success'])
            else:
                LOG.error(
                    'Failed to process %s: %s',
                    mod,
                    status[mod]['stderr'].decode('utf-8')
                )
                exit(EX_SOFTWARE)
        else:
            LOG.info('Not a pull request. Skipping')

    if pull_request:
        post_comment(
            comment=render_comment(status)
        )
    else:
        print(status)
